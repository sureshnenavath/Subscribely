
// Database Prompt (SQLite Schema)
I am designing the database for a subscription SaaS platform called Subscribely. 
The database will be implemented using SQLite (instead of MySQL) and must support users, plans, subscriptions, payments, and webhook events.

Database structure Code:
-- Users table compatible with Django user model
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT NOT NULL UNIQUE,
    email TEXT NOT NULL UNIQUE,
    password TEXT NOT NULL,
    first_name TEXT,
    last_name TEXT,
    is_active BOOLEAN NOT NULL DEFAULT 1,
    is_staff BOOLEAN NOT NULL DEFAULT 0,
    is_superuser BOOLEAN NOT NULL DEFAULT 0,
    date_joined DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Plans table
CREATE TABLE plans (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    monthly_price REAL NOT NULL,
    yearly_price REAL NOT NULL,
    features TEXT NOT NULL,
    trial_days INTEGER NOT NULL
);

-- Subscriptions table
CREATE TABLE subscriptions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    plan_id INTEGER NOT NULL,
    status TEXT CHECK(status IN ('active', 'cancelled', 'expired', 'pending')) NOT NULL,
    start_date DATETIME NOT NULL,
    end_date DATETIME NOT NULL,
    cancel_date DATETIME,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (plan_id) REFERENCES plans(id)
);

-- Payments table
CREATE TABLE payments (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    subscription_id INTEGER NOT NULL,
    amount REAL NOT NULL,
    method TEXT CHECK(method IN ('UPI', 'Card')) NOT NULL,
    status TEXT CHECK(status IN ('success', 'failed', 'pending')) NOT NULL,
    raw_response TEXT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (subscription_id) REFERENCES subscriptions(id)
);

-- Webhook events table
CREATE TABLE webhook_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_type TEXT NOT NULL,
    payload TEXT NOT NULL,
    processed BOOLEAN NOT NULL DEFAULT 0
);

-- Indexes for foreign keys
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_plan_id ON subscriptions(plan_id);
CREATE INDEX idx_payments_user_id ON payments(user_id);
CREATE INDEX idx_payments_subscription_id ON payments(subscription_id);


// Backend Prompt (Django + DRF)
I am building the backend of a subscription SaaS platform called Subscribely using Django + DRF with SQLite. 
The platform supports three subscription plans and Razorpay payments (UPI & card) in test mode, and uses JWT authentication for signup/login.

Requirements:
1. Authentication (JWT with HTTP-only cookies)
- Signup API (POST /api/auth/signup/): Accept first_name, last_name, email, username, password, confirm_password. Validate passwords. Create user, return JWT in secure HTTP-only cookie (1-day expiration).
- Login API (POST /api/auth/login/): Accept email/password, return JWT in cookie. Skip login if token valid.
- Logout clears cookie.

2. Plans API
- GET /api/plans/ – List subscription plans with features & prices.
- Admin can create/update/delete plans.

3. Subscription API
- POST /api/subscriptions/subscribe/ – User selects a plan, create subscription with status "pending". Generate Razorpay session.
- POST /api/subscriptions/<id>/cancel/ – Cancel subscription, update status & set cancel_date.
- POST /api/subscriptions/<id>/renew/ – Renew subscription, update end_date based on plan duration.
- GET /api/subscriptions/ – List user’s subscriptions.

4. Payment Integration (Razorpay test mode)
- Keys:
  - Key ID: rzp_test_RIcK2VIpRxbMbg
  - Key Secret: 4G78tnRQoskxKS0bbA6i88Vj
- On plan selection, generate checkout session.
- POST /api/webhooks/razorpay/ – Handle webhook events for success/failure.
- Success → subscription active, set start_date & end_date.
- Failure → subscription failed.

5. Models & Database
- Models: Users, Plans, Subscriptions, Payments, WebhookEvents.
- Include cancel_date in subscriptions.
- Payments store Razorpay ID, amount, method, status, raw response.

6. Security & Validation
- JWT only in HTTP-only cookies.
- Hash passwords with Django’s default hasher.
- Validate inputs & Razorpay responses.
- Do not store raw card data.

7. Admin & Access Control
- Admin manages plans in Django admin.
- Subscriber-only content locked behind active subscription.

8. Deployment & Testing
- Use Docker Compose for deployment.
- Add automated tests for signup/login, subscription flow, payments, and renewal.

9. Documentation
- README with setup, sandbox payment config, and API docs.
- Postman collection or curl examples.


// Frontend Prompt (React)
I am building the frontend of Subscribely using React (latest). The backend is Django + DRF with JWT, SQLite, and Razorpay integration.

Requirements:
1. Authentication
- Signup page with fields: first_name, last_name, email, username, password, confirm_password.
- Login page with email & password.
- Store JWT in HTTP-only cookie. Redirect logic:
  - New user → signup page.
  - Logged-in user → dashboard.
  - Expired/invalid token → login.
- Logout clears JWT cookie.

2. Dashboard
- Show user profile info.
- Show active subscription details (plan, start_date, end_date, status).
- Cancel subscription option.
- Renew subscription option.
- If no active subscription → redirect to plans page.

3. Plans Page
- Fetch from /api/plans/.
- Show all plans (Basic, Pro, Pro Plus).
- Subscribe button → calls backend to create subscription + Razorpay checkout session.
- On payment success → subscription active.

4. Payments Page
- Show history (amount, method, status, date).
- Reflect Razorpay success/failure via webhook updates.

5. Admin Dashboard (Optional)
- Manage plans.
- View subscriptions, payments, webhook events.

6. Routing & Access Control
- React Router for navigation.
- Protect routes for authenticated & subscribed users.
- Redirect logic consistent with JWT state.

7. State Management & API Integration
- Use Context/Redux for auth, subscription, payments.
- Axios for API calls, attach JWT cookie.
- Error handling + loading states.

8. UI/UX (User-Friendly & Responsive)
- Design must be **modern, intuitive, and mobile-first responsive**.
- Reusable UI components (cards, tables, modals, buttons).
- Light/dark mode switch.
- Smooth animations and transitions for better UX.
- Provide **clear error messages, tooltips, and form validations**.
- Accessible design (keyboard navigation, ARIA labels).
- Dashboard and plans page should dynamically update after actions (subscribe, cancel, renew).

9. Testing
- Add tests for auth, subscription flows, and payment handling.
- Ensure UI responsiveness across devices (desktop, tablet, mobile).
